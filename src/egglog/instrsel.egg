; header =  R"***(

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Datatype declarations
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(datatype BinOp
    (Add)
    (Sub)
    (Mul)
    (Div)
    (Mod)
    (Min)
    (Max)
    (EQ)
    (NE)
    (LT)
    (LE)
    (GT)
    (GE)
    (And)
    (Or))
(datatype UnaOp
    (Not))

; TODO
(datatype Buffer)
(datatype Parameter)
(datatype Type
    ;;  bits x lanes
    (Int i64 i64)
    (UInt i64 i64)
    (Float i64 i64)
    (BFloat i64 i64)
    (Handle i64)
)

; true if the type is signed
(function UIntOrInt (bool i64 i64) Type)
(birewrite (UIntOrInt false i l) (UInt i l))
(birewrite (UIntOrInt true i l) (Int i l))

(sort VecInt (Vec i64))
(sort Expr)
(sort VecExpr (Vec Expr))

(function Cast (Type Expr) Expr)
(function Reinterpret (Type Expr) Expr)
(function Bop (BinOp Expr Expr) Expr)
(function Uop (UnaOp Expr) Expr)
;; condition true_val false_val
(function Select (Expr Expr Expr) Expr)
;; name index
(function Load (Type String Expr) Expr)
;; base stride lanes
(function Ramp (Expr Expr i64) Expr :cost 100)
;; value lanes
(function Broadcast (Expr i64) Expr :cost 100)
;; name value body
;; TODO: Not sure if we need this one, binding is tricky
(function Let (String Expr Expr) Expr)
;; This one is also tricky
(function Call (String Type VecExpr) Expr)
;; name
;; TODO: there are some arguments that are ignored here
(function Var (Type String) Expr)
(function Shuffle (VecExpr VecInt) Expr)
(function VectorReduce (Type BinOp Expr) Expr)
;;                bits val
(function IntImm (i64  i64) Expr)
; u64 is not supported in egglog
(function UIntImm (i64  i64) Expr)
(function FloatImm (i64 f64) Expr)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Helpers
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(function IntImm64 (i64) Expr)
(birewrite (IntImm64 x) (IntImm 64 x))
(function IntImm32 (i64) Expr)
(birewrite (IntImm32 x) (IntImm 32 x))
(function IntImm16 (i64) Expr)
(birewrite (IntImm16 x) (IntImm 16 x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Properties
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(relation CommBop (BinOp))
(CommBop (Add))
(CommBop (Mul))
(CommBop (And))
(CommBop (Or))
(CommBop (Min))
(CommBop (Max))
(CommBop (EQ))
(CommBop (NE))

(relation AddOrSub (BinOp))
(AddOrSub (Add))
(AddOrSub (Sub))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Analysis rules
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; IsExpr
(relation IsExpr (Expr))
(rule ((= e (Cast _type _expr))) ((IsExpr e)))
(rule ((= e (Reinterpret _type _expr))) ((IsExpr e)))
(rule ((= e (Bop BinOp _expr1 _expr2))) ((IsExpr e)))
(rule ((= e (Select _expr1 _expr2 _expr3))) ((IsExpr e)))
(rule ((= e (Load _type _string _expr))) ((IsExpr e)))
(rule ((= e (Ramp _expr1 _expr2 _i64))) ((IsExpr e)))
(rule ((= e (Broadcast _expr _i64))) ((IsExpr e)))
(rule ((= e (Let _string _expr1 _expr2))) ((IsExpr e)))
(rule ((= e (Call _string _type _vecexpr))) ((IsExpr e)))
(rule ((= e (Var _type _string))) ((IsExpr e)))
(rule ((= e (Shuffle _vecexpr _vecint))) ((IsExpr e)))
(rule ((= e (VectorReduce _type _binop _expr))) ((IsExpr e)))
(rule ((= e (IntImm _bits _i64))) ((IsExpr e)))


;; Type checking
(function MultipliedLanes (Type i64) Type)
(rewrite (MultipliedLanes (Int i l) x) (Int i (* l x)))
(rewrite (MultipliedLanes (UInt i l) x) (UInt i (* l x)))
(rewrite (MultipliedLanes (Float i l) x) (Float i (* l x)))
(rewrite (MultipliedLanes (BFloat i l) x) (BFloat i (* l x)))
(rewrite (MultipliedLanes (Handle l) x) (Handle (* l x)))

(function LanesInType (Type) i64)
(rewrite (LanesInType (Int i l)) l)
(rewrite (LanesInType (UInt i l)) l)
(rewrite (LanesInType (Float i l)) l)
(rewrite (LanesInType (BFloat i l)) l)
(rewrite (LanesInType (Handle l)) l)


(relation has-type (Expr Type))
(rule ((= e (Cast ty Expr))) ((has-type e ty)))
(rule ((= e (Reinterpret ty Expr))) ((has-type e ty)))
(rule (
    (= e (Bop bop e1 e2))
    (has-type e1 t)
    (has-type e2 t)
) ((has-type e t)))
(rule ((= e (Select cond tval fval))
    (has-type cond (UInt 1 _lanes))
    (has-type tval ty)
    (has-type fval ty)
) ((has-type e ty)))
(rule ((= e (Load ty name child))) ((has-type e ty)))
(rule ((= e (Ramp child s l)) 
    (has-type child ty)
) ((has-type e (MultipliedLanes ty l))))
(rule ((= e (Broadcast child l)) (has-type child ty)) 
    ((has-type e (MultipliedLanes ty l))))
(rule ((= e (Let x e1 e2))) 
    ((panic "let not supported")))
(rule ((= e (Call fn out-type args))
) ((has-type e out-type)))
(rule ((= e (Var ty x))) ((has-type e ty)))
(rule ((= e (Shuffle VecExpr VecInt))) 
    ((panic "not supported")))
(rule ((= e (VectorReduce ty BinOp Expr))) 
    ((has-type e ty)))
(rule ((= e (IntImm bits i64))) ((has-type e (Int bits 1))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Emitting rules
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Int8/UInt8
(rule (
    (= e (Bop (Add) 
        (VectorReduce (Int 32 out-lanes) (Add) 
            (Bop (Mul) 
                (Cast (Int 32 tot-lanes) (Load (UIntOrInt lhs-signed 8 tot-lanes) lhs-name lhs-index)) 
                (Cast (Int 32 tot-lanes) (Load (UIntOrInt rhs-signed 8 tot-lanes) rhs-name rhs-index)))
            )
        mat))
    (= out-lanes (* x-lanes y-lanes))
    (= tot-lanes (* out-lanes r-lanes))

    ;; LHS
    (= lhs-index
        (Ramp (Broadcast (Ramp lhs-base lhs-r-stride r-lanes) y-lanes) 
              (Broadcast x-stride (* y-lanes r-lanes))
              x-lanes)
    )
    (= lhs-r-stride (IntImm32 1))

    ; RHS
    (= rhs-index
        ; 4 is for (u)int8
        (Broadcast
            (Ramp (Ramp (Ramp rhs-base (IntImm32 1) 4) 
                        (Broadcast rhs-r-stride 4) 
                        (/ r-lanes 4)
                        )
                  ; (Broadcast (IntImm32 4) r-lanes)
                  (Broadcast rhs-stride-1 r-lanes)
                  y-lanes
            )
            x-lanes
        )
    )
) (
    (let new-lhs (Call "tile_load" (UIntOrInt lhs-signed 8 1024) (vec-of (IntImm16 x-lanes) (IntImm16 r-lanes) (Var (Handle 1) lhs-name) lhs-base x-stride)))
    (let new-rhs (Call "tile_load" (UIntOrInt rhs-signed 8 1024) (vec-of (IntImm16 (/ r-lanes 4)) (IntImm16 (* y-lanes 4)) (Var (Handle 1) rhs-name) rhs-base rhs-r-stride)))
    (let new-e (Call "tile_matmul" (Int 32 256) (vec-of (IntImm16 x-lanes) (IntImm16 (* y-lanes 4)) (IntImm16 (/ r-lanes 4)) mat new-lhs new-rhs)))
    (union e new-e)
))

; BFloat16
(rule (
    (= e (Bop (Add) 
        (VectorReduce (Float 32 out-lanes) (Add) 
            (Bop (Mul) 
                (Cast (Float 32 tot-lanes) (Load (BFloat 16 tot-lanes) lhs-name lhs-index)) 
                (Cast (Float 32 tot-lanes) (Load (BFloat 16 tot-lanes) rhs-name rhs-index)))
            )
        mat))
    (= out-lanes (* x-lanes y-lanes))
    (= tot-lanes (* out-lanes r-lanes))

    ; LHS
    (= lhs-index
        (Ramp (Broadcast (Ramp lhs-base lhs-r-stride r-lanes) y-lanes) 
              (Broadcast x-stride (* y-lanes r-lanes))
              x-lanes)
    )
    (= lhs-r-stride (IntImm32 1))

    ; RHS
    (= rhs-index
        (Broadcast
            (Ramp (Ramp (Ramp rhs-base (IntImm32 1) 2) 
                        (Broadcast rhs-r-stride 2)
                        (/ r-lanes 2)
                        )
                  ; (Broadcast (IntImm32 2) r-lanes)
                  (Broadcast rhs-stride-1 r-lanes)
                  y-lanes
            )
            x-lanes
        )
    )
) (
    (let new-lhs (Call "tile_load" (BFloat 16 512) (vec-of (IntImm16 x-lanes) (IntImm16 r-lanes) (Var (Handle 1) lhs-name) lhs-base x-stride)))
    (let new-rhs (Call "tile_load" (BFloat 16 512) (vec-of (IntImm16 (/ r-lanes 2)) (IntImm16 (* y-lanes 2)) (Var (Handle 1) rhs-name) rhs-base rhs-r-stride)))
    (let new-e (Call "tile_matmul" (Float 32 256) (vec-of (IntImm16 x-lanes) (IntImm16 (* y-lanes 4)) (IntImm16 (/ r-lanes 4)) mat new-lhs new-rhs)))
    (union e new-e)
))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Constant folding
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rewrite (Bop (Add) (IntImm bits a) (IntImm bits b)) (IntImm bits (+ a b)))
(rewrite (Bop (Sub) (IntImm bits a) (IntImm bits b)) (IntImm bits (- a b)))
(rewrite (Bop (Mul) (IntImm bits a) (IntImm bits b)) (IntImm bits (* a b)))
(rewrite (Bop (Div) (IntImm bits a) (IntImm bits b)) (IntImm bits (/ a b)))
(rewrite (Bop (Mod) (IntImm bits a) (IntImm bits b)) (IntImm bits (% a b)))
(rewrite (Bop (Min) (IntImm bits a) (IntImm bits b)) (IntImm bits (min a b)))
(rewrite (Bop (Max) (IntImm bits a) (IntImm bits b)) (IntImm bits (max a b)))
(rewrite (Bop (EQ) (IntImm bits a) (IntImm bits b)) (UIntImm 1 1) :when ((= a b)))
(rewrite (Bop (EQ) (IntImm bits a) (IntImm bits b)) (UIntImm 1 0) :when ((!= a b)))
(rewrite (Bop (NE) (IntImm bits a) (IntImm bits b)) (UIntImm 1 0) :when ((= a b)))
(rewrite (Bop (NE) (IntImm bits a) (IntImm bits b)) (UIntImm 1 1) :when ((!= a b)))
(rewrite (Bop (LT) (IntImm bits a) (IntImm bits b)) (UIntImm 1 1) :when ((< a b)))
(rewrite (Bop (LT) (IntImm bits a) (IntImm bits b)) (UIntImm 1 0) :when ((>= a b)))
(rewrite (Bop (LE) (IntImm bits a) (IntImm bits b)) (UIntImm 1 1) :when ((<= a b)))
(rewrite (Bop (LE) (IntImm bits a) (IntImm bits b)) (UIntImm 1 0) :when ((> a b)))
(rewrite (Bop (GT) (IntImm bits a) (IntImm bits b)) (UIntImm 1 1) :when ((> a b)))
(rewrite (Bop (GT) (IntImm bits a) (IntImm bits b)) (UIntImm 1 0) :when ((<= a b)))
(rewrite (Bop (GE) (IntImm bits a) (IntImm bits b)) (UIntImm 1 1) :when ((>= a b)))
(rewrite (Bop (GE) (IntImm bits a) (IntImm bits b)) (UIntImm 1 0) :when ((< a b)))
; TODO: logical operators

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Axiomatic rewrites
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rewrite 
    (Broadcast (Broadcast x l0) l1)
    (Broadcast x (* l0 l1))
)

(rewrite (Bop bop a b) (Bop bop b a) :when ((CommBop bop)))

(rewrite (Broadcast x 1) x)
(rewrite (Broadcast (Load type name index) lanes) 
         (Load (MultipliedLanes type lanes) name (Broadcast index lanes)))
(rewrite (Broadcast (Cast type expr) lanes) 
         (Cast (MultipliedLanes type lanes) (Broadcast expr lanes)))

(rewrite (Bop bop (Broadcast a l1) (Broadcast b l2))
         (Broadcast (Bop bop (Broadcast a (/ l1 l2)) b) l2)
    :when ((> l1 l2)
           (= 0 (% l1 l2))))

(rewrite (Bop bop (Broadcast a l1) (Broadcast b l2))
         (Broadcast (Bop bop a (Broadcast b (/ l2 l1))) l1)
    :when ((< l1 l2)
           (= 0 (% l2 l1))))

(rewrite (Bop bop (Broadcast a l1) (Ramp x s l2))
         (Bop bop (Broadcast (Broadcast a (/ l1 l2)) l2) (Ramp x s l2))
    :when ((> l1 l2)
           (= 0 (% l1 l2))))

(rewrite (Bop bop (Ramp x s l2) (Broadcast a l1))
         (Bop bop (Ramp x s l2) (Broadcast (Broadcast a (/ l1 l2)) l2))
    :when ((> l1 l2)
           (= 0 (% l1 l2))))


(rewrite (Bop bop (Broadcast a l) (Broadcast b l))
         (Broadcast (Bop bop a b) l))

(rewrite (Bop add-or-sub (Ramp base stride lanes) (Broadcast x lanes))
         (Ramp (Bop (Add) base x) stride lanes)
    :when ((AddOrSub add-or-sub)))
(rewrite (Bop add-or-sub (Ramp b1 s1 l) (Ramp b2 s2 l))
         (Ramp (Bop add-or-sub b1 b2) (Bop add-or-sub s1 s2) l)
    :when ((AddOrSub add-or-sub)))
(rewrite (Bop (Mul) (Ramp b s l) (Broadcast x l))
         (Ramp (Bop (Mul) b x) (Bop (Mul) s x) l))

; TODO: this can be generalized
(rewrite (Bop (Mod) (Ramp (IntImm bits base) (IntImm bits 1) lanes) (Broadcast (IntImm bits x) lanes))
         (Broadcast (Ramp (IntImm bits 0) (IntImm bits 1) x) (/ lanes x))
    :when ((= (% lanes x) 0)
           (= (% base x) 0)))
; (0:1:8) / x8(4) -> (x4(0):x4(1):2)
(rewrite (Bop (Div) (Ramp (IntImm bits base) (IntImm bits 1) lanes) (Broadcast (IntImm bits x) lanes))
         (Ramp (Broadcast (IntImm bits (/ base x)) x) (Broadcast (IntImm bits 1) x) (/ lanes x))
        :when ((= (% lanes x) 0)
               (= (% base x) 0)))


(rewrite (Bop add-or-sub (Ramp base stride r-lanes) (Broadcast x b-lanes))
         (Ramp (Bop add-or-sub base (Broadcast x (/ b-lanes r-lanes))) stride r-lanes)
    :when ((= 0 (% b-lanes r-lanes))
           (AddOrSub add-or-sub) ))
(rewrite (Ramp x s 1) x)

(rewrite x (Ramp x (Broadcast (IntImm b 0) l) 1) 
    :when (
        (IsExpr x) 
        (has-type x (Int b l))))
(rewrite x (Broadcast x 1) :when ((IsExpr x)))
; reorganize a ramp as a 4-column tiles
(rewrite (Ramp e (IntImm b 1) l) 
         (Ramp (Ramp e (IntImm b 1) 4) (Broadcast (IntImm b 4) 4) (/ l 4)) 
  :when ((= 0 (% l 4))))
(rewrite (Ramp e (IntImm b 1) l) 
         (Ramp (Ramp e (IntImm b 1) 2) (Broadcast (IntImm b 2) 2) (/ l 2)) 
  :when ((= 0 (% l 2))))




(let int64x1 (Int 64 1))


; )***"; header += "\n";

