; prog +=  R"***(

;; Type checking
(function MultipliedLanes (Type i64) Type)
(rewrite (MultipliedLanes (Int i l) x) (Int i (* l x)) :ruleset typechecking)
(rewrite (MultipliedLanes (UInt i l) x) (UInt i (* l x)) :ruleset typechecking)
(rewrite (MultipliedLanes (Float i l) x) (Float i (* l x)) :ruleset typechecking)
(rewrite (MultipliedLanes (BFloat i l) x) (BFloat i (* l x)) :ruleset typechecking)
(rewrite (MultipliedLanes (Handle l) x) (Handle (* l x)) :ruleset typechecking)

(function LanesInType (Type) i64)
(rule ((= t (Int i l)))
      ((set (LanesInType t) l)) :ruleset typechecking)
(rule ((= t (UInt i l)))
      ((set (LanesInType t) l)) :ruleset typechecking)
(rule ((= t (Float i l)))
      ((set (LanesInType t) l)) :ruleset typechecking)
(rule ((= t (BFloat i l)))
      ((set (LanesInType t) l)) :ruleset typechecking)
(rule ((= t (Handle l)))
      ((set (LanesInType t) l)) :ruleset typechecking)

(function WithLanes (Type i64) Type)
(rewrite (WithLanes (Int i l) x) (Int i x) :ruleset typechecking)
(rewrite (WithLanes (UInt i l) x) (UInt i x) :ruleset typechecking)
(rewrite (WithLanes (Float i l) x) (Float i x) :ruleset typechecking)
(rewrite (WithLanes (BFloat i l) x) (BFloat i x) :ruleset typechecking)
(rewrite (WithLanes (Handle l) x) (Handle x) :ruleset typechecking)

(relation has-type (Expr Type))
(rule ((= e (Cast ty Expr))) ((has-type e ty)) :ruleset typechecking)
(rule ((= e (Reinterpret ty Expr))) ((has-type e ty)) :ruleset typechecking)
(rule (
    (= e (Bop bop e1 e2))
    (has-type e1 t)
    (has-type e2 t)
) ((has-type e t)) :ruleset typechecking)
(rule (
    (= e (Uop uop e1))
    (has-type e1 t)
) ((has-type e t)) :ruleset typechecking)
(rule ((= e (Select cond tval fval))
    (has-type cond (UInt 1 _lanes))
    (has-type tval ty)
    (has-type fval ty)
) ((has-type e ty)) :ruleset typechecking)
(rule ((= e (Load ty name child))) ((has-type e ty)) :ruleset typechecking)
(rule ((= e (Ramp child s l)) 
    (has-type child ty)
) ((has-type e (MultipliedLanes ty l))) :ruleset typechecking)
(rule ((= e (Broadcast child l)) (has-type child ty)) 
    ((has-type e (MultipliedLanes ty l))) :ruleset typechecking)
(rule ((= e (Let x e1 e2))) 
    ((panic "let not supported")) :ruleset typechecking)
(rule ((= e (Call fn out-type args))
) ((has-type e out-type)) :ruleset typechecking)
(rule ((= e (Var ty x))) ((has-type e ty)) :ruleset typechecking)
(rule ((= e (Shuffle VecExpr VecInt))) 
    ((panic "not supported")) :ruleset typechecking)
(rule ((= e (VectorReduce ty BinOp Expr))) 
    ((has-type e ty)) :ruleset typechecking)
(rule ((= e (IntImm bits i64))) ((has-type e (Int bits 1))) :ruleset typechecking)
(rule ((= e (UIntImm bits i64))) ((has-type e (UInt bits 1))) :ruleset typechecking)
(rule ((= e (FloatImm bits f64))) ((has-type e (Float bits 1))) :ruleset typechecking)

;; extensions
(rule (
    (= e (Loc2Loc l1 l2 e1))
    (has-type e1 t)
) (
    (has-type e t)
) :ruleset typechecking)
(rule (
    (= e (BroadcastPer p e1 l))
    (has-type e1 t)
) (
    (has-type e (MultipliedLanes t l))
) :ruleset typechecking)

(rule ((has-type e t1) (has-type e t2) (!= t1 t2)) ((extract e) (extract t1) (extract t2) (panic "?")))

; )***"; prog += "\n";
