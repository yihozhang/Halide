; prog +=  R"***(

;; different from AMX, the last column denotes number of elements rather than colbytes
(relation WMMAAllocation (String i64 i64))
(relation WMMAShape (Expr i64 i64))

(rule (
        (WMMAAllocation name rows cols)
        (= e (Var t (V name)))
    ) (
        (WMMAShape e rows cols)
    ))
(rule (
        (WMMAShape e rows cols)
        (Store name e index)
    ) (
        (WMMAAllocation name rows cols)
    ))
; TODO: this rule is wrong: it requires the index to be a linear scan instead of an arbitrary expression
(rule (
        (WMMAAllocation name rows cols)
        (Store name e index)
    ) (
        (WMMAShape e rows cols)
    ))


(rule (
        (= e (Bop (Add)
                (VectorReduce (Float 32 out-lanes) (Add)
                    (Bop (Mul)
                        (Cast (Float 32 tot-lanes) lhs)
                        (Cast (Float 32 tot-lanes) rhs))
                )
                mat))
        (= out-lanes (* x-lanes y-lanes))
        (= tot-lanes (* out-lanes r-lanes))

        (= lhs (Load (Float 16 tot-lanes) lhs-name lhs-index))
        (= lhs-index
            (Ramp (Broadcast (Ramp lhs-base (IntImm32 1) r-lanes) y-lanes)
                (Broadcast x-stride (* y-lanes r-lanes))
                x-lanes)
        )

        (= rhs (Load (Float 16 tot-lanes) rhs-name rhs-index))
        (= rhs-index
            (Broadcast
                (Ramp (Ramp rhs-base
                        rhs-r-stride
                        r-lanes
                    )
                    (Broadcast (IntImm32 1) r-lanes)
                    y-lanes
                )
                x-lanes
            )
        )

        (= x-lanes 16)
        (= y-lanes 16)
        (= r-lanes 16)
    ) (
        (let new-lhs (Call "wmma.load.a.sync.aligned.row.m16n16k16.f16" (Float 16 256) (vec-of (Var (Handle 1) lhs-name) lhs-base x-stride)))
        (let new-rhs (Call "wmma.load.b.sync.aligned.row.m16n16k16.f16" (Float 16 256) (vec-of (Var (Handle 1) rhs-name) rhs-base rhs-r-stride)))
        (let new-mat (Mem2WMMA mat))
        (let new-e (Call "wmma.mma.sync.aligned.row.row.m16n16k16.f32.f32" (Float 32 256) (vec-of new-mat new-lhs new-rhs)))
        (WMMAShape new-e x-lanes y-lanes)

        (union e (WMMA2Mem new-e))
    ))


(rule (
        (= e (Mem2WMMA
                (Broadcast
                    (FloatImm 32 0.0)
                    lanes
                )))
        (WMMAShape e rows cols)
        (= lanes (* rows cols))

        (= rows 16)
        (= cols 16)
    ) (
        (let new-e (Call "wmma.load.c.sync.aligned.row.m16n16k16.f32" (Float 32 lanes) (vec-of (Var (Handle 1) (ExprVar (Mem) (Broadcast (FloatImm 32 0.0) 256))) (IntImm32 0) (IntImm32 16))))
        (union e new-e)
    ))

(rule (
        (= s (Store store-name (WMMA2Mem tile) index))
        (= index (Ramp (Ramp base (IntImm32 1) m-lanes) (Broadcast n-stride m-lanes) n-lanes))
        (= bytes 4)
        (has-type value ty)

        (= m-lanes 16)
        (= n-lanes 16)
    ) (
        (let new-s (Evaluate
                (Call "wmma.store.d.sync.aligned.row.m16n16k16.f32" (Int 32 1)
                    (vec-of (Var (Handle 1) (V store-name))
                        tile
                        (Bop (Mul) n-stride (IntImm32 bytes))
                    ))))
        (union s new-s)
    ))

; )***"; prog += "\n";
